# Two pointers
Used when going through a linnear structure(arr or linked list or strings).

Instead of brute force approach where you search the whole array for every element, two pointers approach improves it and reduces time complexity from n^2 to n.

Use case:
Pointers move in same dicrection. One is faster than the other one. Exampe: find middle of linked list.
Opposite direction. Example: find duplicates.


# Binary search
It requires a sorted array!!! Here you divide steps by 2 to achieve T:O(log n).

# Breadth-first search
Going through tree level-by-leve from top to bottom. Uses a queue.
It is the best for searching the shortest path or reporting tree by levels.

# Depth-first search
You go deep in one route to explore all nodes before you explore other nodes. Uses a call stack(recursion).
It is the best used for exploring all paths in the tree.


# Priority queue
Use it every time problem says "Find Kth largest/smallest elements in array", "Top K elements", "K closest elements to origin". 

# Dynamic problem
Breaking down a complex problem into set of simpler underlying propblems AND reusing result of those undelying problems to solve the original problem.
## Approaches
Top-down: TODO.
Bbottom-up: More efficient: Example: CoinChange, Break strings in words from dict.



<!-- 
Reverse the second half of a linked list​
Find all anagrams in a string​
Merge overlapping intervals -->